# helper_mcp.py
# MCPÔºàModel Context ProtocolÔºâÈñ¢ÈÄ£„ÅÆ„Éò„É´„Éë„ÉºÈñ¢Êï∞„Å®„ÇØ„É©„Çπ
# „Éá„Éº„Çø„Éô„Éº„ÇπÁÆ°ÁêÜ„ÄÅUIÁÆ°ÁêÜ„ÄÅ„Éö„Éº„Ç∏ÁÆ°ÁêÜ„ÇíÂê´„ÇÄ

import streamlit as st
import redis
import psycopg2
import sqlalchemy
import requests
import pandas as pd
import json
import time
import traceback
import os
from datetime import datetime
from typing import Dict, Any, List, Optional
from abc import ABC, abstractmethod


# ==================================================
# Ë®≠ÂÆö„Å®„Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ
# ==================================================
class MCPSessionManager:
    """MCP„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Áî®„ÅÆ„Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ"""

    @staticmethod
    def init_session():
        """„Çª„ÉÉ„Ç∑„Éß„É≥Áä∂ÊÖã„ÅÆÂàùÊúüÂåñ"""
        if 'messages' not in st.session_state:
            st.session_state.messages = []
        if 'selected_tab_index' not in st.session_state:
            st.session_state.selected_tab_index = 0
        if 'auto_process_question' not in st.session_state:
            st.session_state.auto_process_question = False
        if 'server_status_cache' not in st.session_state:
            st.session_state.server_status_cache = {}
        if 'last_status_check' not in st.session_state:
            st.session_state.last_status_check = 0


# ==================================================
# „Éá„Éº„Çø„Éô„Éº„ÇπÁÆ°ÁêÜ„ÇØ„É©„ÇπÁæ§
# ==================================================
class DatabaseManager(ABC):
    """„Éá„Éº„Çø„Éô„Éº„ÇπÁÆ°ÁêÜ„ÅÆÂü∫Â∫ï„ÇØ„É©„Çπ"""

    def __init__(self, name: str):
        self.name = name

    @abstractmethod
    def check_connection(self) -> Dict[str, str]:
        """Êé•Á∂öÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
        pass

    @abstractmethod
    def get_data_summary(self) -> Dict[str, Any]:
        """„Éá„Éº„Çø„ÅÆÊ¶ÇË¶Å„ÇíÂèñÂæó"""
        pass


class RedisManager(DatabaseManager):
    """RedisÁÆ°ÁêÜ„ÇØ„É©„Çπ"""

    def __init__(self):
        super().__init__("Redis")
        self.host = 'localhost'
        self.port = 6379
        self.db = 0

    def check_connection(self) -> Dict[str, str]:
        """RedisÊé•Á∂öÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
        try:
            r = redis.Redis(host=self.host, port=self.port, db=self.db, socket_connect_timeout=3)
            r.ping()
            return {"status": "üü¢ Êé•Á∂öOK", "details": "Ê≠£Â∏∏"}
        except Exception as e:
            return {"status": f"üî¥ Êé•Á∂öNG", "details": str(e)[:50]}

    def get_data_summary(self) -> Dict[str, Any]:
        """Redis„Éá„Éº„Çø„ÅÆÊ¶ÇË¶ÅÂèñÂæó"""
        try:
            r = redis.Redis(host=self.host, port=self.port, db=self.db, decode_responses=True)

            # „Ç≠„ÉºÊï∞„ÇíÂÆâÂÖ®„Å´ÂèñÂæó
            count = 0
            for _ in r.scan_iter():
                count += 1
                if count > 1000:
                    return {"key_count": f"{count}+", "status": "partial"}

            return {
                "key_count"    : str(count),
                "status"       : "complete",
                "session_count": len(r.keys('session:*')),
                "counter_count": len(r.keys('counter:*'))
            }
        except Exception:
            return {"key_count": "?", "status": "error"}

    def get_detailed_data(self) -> Dict[str, Any]:
        """RedisË©≥Á¥∞„Éá„Éº„ÇøÂèñÂæó"""
        try:
            r = redis.Redis(host=self.host, port=self.port, db=self.db, decode_responses=True)

            # „Çª„ÉÉ„Ç∑„Éß„É≥„Éá„Éº„Çø
            session_keys = list(r.scan_iter('session:*'))
            session_data = []
            for key in sorted(session_keys):
                data = r.hgetall(key)
                data['session_key'] = key
                session_data.append(data)

            # „Ç´„Ç¶„É≥„Çø„Éá„Éº„Çø
            counter_keys = list(r.scan_iter('counter:*'))
            counter_data = {}
            for key in sorted(counter_keys):
                counter_data[key.replace('counter:', '')] = r.get(key)

            # „Åù„ÅÆ‰ªñ„ÅÆ„Éá„Éº„Çø
            categories = list(r.smembers('categories:all'))
            search_history = r.lrange('search:recent', 0, -1)

            return {
                "sessions"      : session_data,
                "counters"      : counter_data,
                "categories"    : categories,
                "search_history": search_history
            }
        except Exception as e:
            st.error(f"RedisË©≥Á¥∞„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº: {e}")
            return {}


class PostgreSQLManager(DatabaseManager):
    """PostgreSQLÁÆ°ÁêÜ„ÇØ„É©„Çπ"""

    def __init__(self):
        super().__init__("PostgreSQL")
        self.conn_str = st.secrets.get('PG_CONN_STR') or os.getenv('PG_CONN_STR')

    def check_connection(self) -> Dict[str, str]:
        """PostgreSQLÊé•Á∂öÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
        try:
            conn = psycopg2.connect(self.conn_str, connect_timeout=3)
            conn.close()
            return {"status": "üü¢ Êé•Á∂öOK", "details": "Ê≠£Â∏∏"}
        except Exception as e:
            return {"status": f"üî¥ Êé•Á∂öNG", "details": str(e)[:50]}

    def get_data_summary(self) -> Dict[str, Any]:
        """PostgreSQL„Éá„Éº„Çø„ÅÆÊ¶ÇË¶ÅÂèñÂæó"""
        try:
            engine = sqlalchemy.create_engine(self.conn_str)

            # „ÉÜ„Éº„Éñ„É´Êï∞„Å®Âü∫Êú¨Áµ±Ë®à
            customers = pd.read_sql("SELECT COUNT(*) as count FROM customers", engine).iloc[0]['count']
            orders = pd.read_sql("SELECT COUNT(*) as count FROM orders", engine).iloc[0]['count']
            products = pd.read_sql("SELECT COUNT(*) as count FROM products", engine).iloc[0]['count']

            engine.dispose()
            return {
                "table_count": 3,
                "customers"  : customers,
                "orders"     : orders,
                "products"   : products,
                "status"     : "complete"
            }
        except Exception:
            return {"table_count": "?", "status": "error"}

    def get_detailed_data(self) -> Dict[str, Any]:
        """PostgreSQLË©≥Á¥∞„Éá„Éº„ÇøÂèñÂæó"""
        try:
            engine = sqlalchemy.create_engine(self.conn_str)

            # ÂêÑ„ÉÜ„Éº„Éñ„É´„ÅÆ„Éá„Éº„Çø
            customers = pd.read_sql("SELECT * FROM customers ORDER BY id LIMIT 10", engine)
            orders = pd.read_sql("""
                                 SELECT o.*, c.name as customer_name
                                 FROM orders o
                                          JOIN customers c ON o.customer_id = c.id
                                 ORDER BY o.order_date DESC
                                 LIMIT 10
                                 """, engine)
            products = pd.read_sql("SELECT * FROM products ORDER BY id", engine)

            # Áµ±Ë®àÊÉÖÂ†±
            total_sales = pd.read_sql("SELECT SUM(price * quantity) as total FROM orders", engine).iloc[0]['total']

            engine.dispose()
            return {
                "customers"  : customers,
                "orders"     : orders,
                "products"   : products,
                "total_sales": total_sales
            }
        except Exception as e:
            st.error(f"PostgreSQLË©≥Á¥∞„Éá„Éº„ÇøÂèñÂæó„Ç®„É©„Éº: {e}")
            return {}


class ElasticsearchManager(DatabaseManager):
    """ElasticsearchÁÆ°ÁêÜ„ÇØ„É©„Çπ"""

    def __init__(self):
        super().__init__("Elasticsearch")
        self.url = 'http://localhost:9200'

    def check_connection(self) -> Dict[str, str]:
        """ElasticsearchÊé•Á∂öÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
        try:
            response = requests.get(f'{self.url}/_cluster/health', timeout=3)
            if response.status_code == 200:
                return {"status": "üü¢ Êé•Á∂öOK", "details": "Ê≠£Â∏∏"}
            else:
                return {"status": f"üî¥ Êé•Á∂öNG", "details": f"Status: {response.status_code}"}
        except Exception as e:
            return {"status": f"üî¥ Êé•Á∂öNG", "details": str(e)[:50]}

    def get_data_summary(self) -> Dict[str, Any]:
        """Elasticsearch„Éá„Éº„Çø„ÅÆÊ¶ÇË¶ÅÂèñÂæó"""
        try:
            response = requests.get(f'{self.url}/blog_articles/_count', timeout=3)
            if response.status_code == 200:
                count = response.json()['count']
                return {"document_count": count, "status": "complete"}
            else:
                return {"document_count": "?", "status": "error"}
        except Exception:
            return {"document_count": "?", "status": "error"}

    def search_articles(self, term: str, field: str = "ÂÖ®„Éï„Ç£„Éº„É´„Éâ") -> List[Dict]:
        """Ë®ò‰∫ãÊ§úÁ¥¢"""
        try:
            if field == "ÂÖ®„Éï„Ç£„Éº„É´„Éâ":
                query = {
                    "query"    : {
                        "multi_match": {
                            "query" : term,
                            "fields": ["title^2", "content", "category", "author"]
                        }
                    },
                    "highlight": {
                        "fields": {
                            "title"  : {},
                            "content": {}
                        }
                    }
                }
            else:
                query = {
                    "query"    : {
                        "match": {
                            field: term
                        }
                    },
                    "highlight": {
                        "fields": {
                            field: {}
                        }
                    }
                }

            response = requests.post(
                f'{self.url}/blog_articles/_search',
                json=query,
                headers={'Content-Type': 'application/json'}
            )

            if response.status_code == 200:
                return response.json()['hits']['hits']
            return []
        except Exception as e:
            st.error(f"ElasticsearchÊ§úÁ¥¢„Ç®„É©„Éº: {e}")
            return []


class QdrantManager(DatabaseManager):
    """QdrantÁÆ°ÁêÜ„ÇØ„É©„Çπ"""

    def __init__(self):
        super().__init__("Qdrant")
        self.url = 'http://localhost:6333'

    def check_connection(self) -> Dict[str, str]:
        """QdrantÊé•Á∂öÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ"""
        try:
            response = requests.get(f'{self.url}/', timeout=3)
            if response.status_code == 200:
                return {"status": "üü¢ Êé•Á∂öOK", "details": "Ê≠£Â∏∏"}
            else:
                return {"status": f"üî¥ Êé•Á∂öNG", "details": f"Status: {response.status_code}"}
        except Exception as e:
            return {"status": f"üî¥ Êé•Á∂öNG", "details": str(e)[:50]}

    def get_data_summary(self) -> Dict[str, Any]:
        """Qdrant„Éá„Éº„Çø„ÅÆÊ¶ÇË¶ÅÂèñÂæó"""
        try:
            response = requests.get(f'{self.url}/collections', timeout=3)
            if response.status_code == 200:
                collections = response.json().get('result', {}).get('collections', [])
                return {
                    "collection_count": len(collections),
                    "collections"     : [col['name'] for col in collections],
                    "status"          : "complete"
                }
            return {"collection_count": "?", "status": "error"}
        except Exception:
            return {"collection_count": "?", "status": "error"}


# ==================================================
# „Çµ„Éº„Éê„ÉºÁä∂ÊÖãÁÆ°ÁêÜ
# ==================================================
class ServerStatusManager:
    """ÂÖ®„Çµ„Éº„Éê„Éº„ÅÆÁä∂ÊÖãÁÆ°ÁêÜ"""

    def __init__(self):
        self.managers = {
            'Redis'        : RedisManager(),
            'PostgreSQL'   : PostgreSQLManager(),
            'Elasticsearch': ElasticsearchManager(),
            'Qdrant'       : QdrantManager()
        }

    @st.cache_data(ttl=30)
    def check_all_servers(_self) -> Dict[str, Dict[str, str]]:
        """ÂÖ®„Çµ„Éº„Éê„Éº„ÅÆÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØÔºà„Ç≠„É£„ÉÉ„Ç∑„É•‰ªò„ÅçÔºâ"""
        status = {}
        for name, manager in _self.managers.items():
            status[name] = manager.check_connection()
        return status

    def get_connected_count(self) -> int:
        """Êé•Á∂öÊ∏à„Åø„Çµ„Éº„Éê„ÉºÊï∞„ÇíÂèñÂæó"""
        status = self.check_all_servers()
        return sum(1 for s in status.values() if "üü¢" in s["status"])

    def get_manager(self, name: str) -> Optional[DatabaseManager]:
        """ÊåáÂÆö„Åï„Çå„Åü„Éá„Éº„Çø„Éô„Éº„Çπ„Éû„Éç„Éº„Ç∏„É£„Éº„ÇíÂèñÂæó"""
        return self.managers.get(name)


# ==================================================
# UIÁÆ°ÁêÜ„ÇØ„É©„Çπ
# ==================================================
class SidebarManager:
    """„Çµ„Ç§„Éâ„Éê„Éº„ÅÆÁÆ°ÁêÜ"""

    def __init__(self, status_manager: ServerStatusManager):
        self.status_manager = status_manager

    def render_server_status(self):
        """„Çµ„Éº„Éê„ÉºÁä∂ÊÖã„ÅÆË°®Á§∫"""
        st.sidebar.header("üìä MCP „Çµ„Éº„Éê„ÉºÁä∂ÊÖã")

        if st.sidebar.button("üîÑ Áä∂ÊÖãÊõ¥Êñ∞"):
            st.cache_data.clear()

        status = self.status_manager.check_all_servers()
        for server, state in status.items():
            st.sidebar.markdown(f"**{server}**: {state['status']}")

        connected_count = self.status_manager.get_connected_count()
        st.sidebar.markdown(f"**Êé•Á∂öÊ∏à„Åø**: {connected_count}/4 „Çµ„Éº„Éê„Éº")

    def render_quick_actions(self):
        """„ÇØ„Ç§„ÉÉ„ÇØ„Ç¢„ÇØ„Ç∑„Éß„É≥„ÅÆË°®Á§∫"""
        st.sidebar.markdown("---")
        st.sidebar.header("‚ö° „ÇØ„Ç§„ÉÉ„ÇØ„Ç¢„ÇØ„Ç∑„Éß„É≥")

        if st.sidebar.button("üöÄ DockerËµ∑Âãï"):
            st.sidebar.code("docker-compose -f docker-compose.mcp-demo.yml up -d")

        if st.sidebar.button("üìä „Éá„Éº„ÇøÂÜçÊäïÂÖ•"):
            st.sidebar.code("uv run python scripts/setup_test_data.py")

    def render_navigation(self, tab_names: List[str]) -> int:
        """„Éä„Éì„Ç≤„Éº„Ç∑„Éß„É≥„ÅÆË°®Á§∫"""
        st.sidebar.markdown("---")
        st.sidebar.header("üìã „Éö„Éº„Ç∏ÈÅ∏Êäû")

        current_tab = st.session_state.selected_tab_index

        for i, tab_name in enumerate(tab_names):
            # ÁèæÂú®„ÅÆ„Çø„Éñ„Åã„Å©„ÅÜ„Åã„ÅßË°®Á§∫„ÇíÂ§â„Åà„Çã
            if i == current_tab:
                st.sidebar.markdown(f"**‚ñ∂ {tab_name}**")
            else:
                if st.sidebar.button(tab_name, key=f"tab_btn_{i}"):
                    st.session_state.selected_tab_index = i
                    st.rerun()

        return current_tab


# ==================================================
# „Éö„Éº„Ç∏ÁÆ°ÁêÜ„ÇØ„É©„ÇπÁæ§
# ==================================================
class PageManager(ABC):
    """„Éö„Éº„Ç∏ÁÆ°ÁêÜ„ÅÆÂü∫Â∫ï„ÇØ„É©„Çπ"""

    def __init__(self, name: str, status_manager: ServerStatusManager):
        self.name = name
        self.status_manager = status_manager

    @abstractmethod
    def render(self):
        """„Éö„Éº„Ç∏„ÅÆÊèèÁîª"""
        pass


class DataViewPage(PageManager):
    """„Éá„Éº„ÇøÁ¢∫Ë™ç„Éö„Éº„Ç∏"""

    def render(self):
        st.write("üìä ÊäïÂÖ•„Åï„Çå„Åü„ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÅÆÁ¢∫Ë™ç")

        # „Éá„Éº„ÇøÊ¶ÇË¶Å„Ç´„Éº„Éâ
        self._render_summary_metrics()

        st.markdown("---")

        # „Éá„Éº„ÇøË©≥Á¥∞Ë°®Á§∫
        self._render_detailed_data()

    def _render_summary_metrics(self):
        """Ê¶ÇË¶Å„É°„Éà„É™„ÇØ„Çπ„ÅÆË°®Á§∫"""
        col1, col2, col3, col4 = st.columns(4)

        with col1:
            redis_manager = self.status_manager.get_manager('Redis')
            redis_summary = redis_manager.get_data_summary()
            st.metric(
                label="Redis Keys",
                value=redis_summary.get('key_count', '?'),
                help="Redis„Å´‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Çã„Ç≠„Éº„ÅÆÁ∑èÊï∞"
            )

        with col2:
            pg_manager = self.status_manager.get_manager('PostgreSQL')
            pg_summary = pg_manager.get_data_summary()
            st.metric(
                label="PostgreSQL Tables",
                value=pg_summary.get('table_count', '?'),
                help="customers, orders, products"
            )

        with col3:
            es_manager = self.status_manager.get_manager('Elasticsearch')
            es_summary = es_manager.get_data_summary()
            st.metric(
                label="ES Documents",
                value=es_summary.get('document_count', '?'),
                help="„Éñ„É≠„Ç∞Ë®ò‰∫ã„ÅÆ„Éâ„Ç≠„É•„É°„É≥„ÉàÊï∞"
            )

        with col4:
            qdrant_manager = self.status_manager.get_manager('Qdrant')
            qdrant_summary = qdrant_manager.get_data_summary()
            st.metric(
                label="Qdrant Collections",
                value=qdrant_summary.get('collection_count', '?'),
                help="„Éô„ÇØ„Éà„É´„Ç≥„É¨„ÇØ„Ç∑„Éß„É≥Êï∞"
            )

    def _render_detailed_data(self):
        """Ë©≥Á¥∞„Éá„Éº„Çø„ÅÆË°®Á§∫"""
        col1, col2 = st.columns(2)

        with col1:
            self._render_redis_details()

        with col2:
            self._render_postgresql_details()

        # ‰ªñ„ÅÆ„Éá„Éº„Çø„Éô„Éº„Çπ„ÇÇÂêåÊßò„Å´
        st.markdown("---")
        self._render_elasticsearch_details()
        self._render_qdrant_details()

    def _render_redis_details(self):
        """RedisË©≥Á¥∞Ë°®Á§∫"""
        st.subheader("üî¥ Redis „Éá„Éº„Çø")
        if st.button("Redis „Éá„Éº„Çø„ÇíË°®Á§∫", key="show_redis"):
            redis_manager = self.status_manager.get_manager('Redis')
            with st.spinner("Redis„Éá„Éº„Çø„ÇíÂèñÂæó‰∏≠..."):
                data = redis_manager.get_detailed_data()

                if data.get('sessions'):
                    st.write("**üîë „Çª„ÉÉ„Ç∑„Éß„É≥„Éá„Éº„Çø:**")
                    df_sessions = pd.DataFrame(data['sessions'])
                    st.dataframe(df_sessions, use_container_width=True)

                if data.get('counters'):
                    st.write("**üìä „Ç´„Ç¶„É≥„Çø„Éá„Éº„Çø:**")
                    counter_cols = st.columns(2)
                    for i, (key, value) in enumerate(data['counters'].items()):
                        with counter_cols[i % 2]:
                            st.metric(key.replace('_', ' ').title(), value)

                # „Åù„ÅÆ‰ªñ„ÅÆ„Éá„Éº„Çø„ÇÇË°®Á§∫

    def _render_postgresql_details(self):
        """PostgreSQLË©≥Á¥∞Ë°®Á§∫"""
        st.subheader("üü¶ PostgreSQL „Éá„Éº„Çø")
        if st.button("PostgreSQL „Éá„Éº„Çø„ÇíË°®Á§∫", key="show_postgres"):
            pg_manager = self.status_manager.get_manager('PostgreSQL')
            with st.spinner("PostgreSQL„Éá„Éº„Çø„ÇíÂèñÂæó‰∏≠..."):
                data = pg_manager.get_detailed_data()

                if 'customers' in data:
                    st.write("**üë• È°ßÂÆ¢„Éá„Éº„Çø:**")
                    st.dataframe(data['customers'], use_container_width=True)

                if 'orders' in data:
                    st.write("**üõí Ê≥®Êñá„Éá„Éº„Çø:**")
                    st.dataframe(data['orders'], use_container_width=True)

                # „Åù„ÅÆ‰ªñ„ÅÆ„Éá„Éº„Çø„ÇÇË°®Á§∫

    def _render_elasticsearch_details(self):
        """ElasticsearchË©≥Á¥∞Ë°®Á§∫"""
        st.subheader("üü° Elasticsearch „Éá„Éº„Çø")
        if st.button("Elasticsearch „Éá„Éº„Çø„ÇíË°®Á§∫", key="show_elasticsearch"):
            # ÂÆüË£Ö„ÅØÂÖÉ„ÅÆ„Ç≥„Éº„Éâ„Å®ÂêåÊßò
            pass

    def _render_qdrant_details(self):
        """QdrantË©≥Á¥∞Ë°®Á§∫"""
        st.subheader("üü† Qdrant „Éá„Éº„Çø")
        if st.button("Qdrant „Éá„Éº„Çø„ÇíË°®Á§∫", key="show_qdrant"):
            # ÂÆüË£Ö„ÅØÂÖÉ„ÅÆ„Ç≥„Éº„Éâ„Å®ÂêåÊßò
            pass


class AIChatPage(PageManager):
    """AI„ÉÅ„É£„ÉÉ„Éà„Éö„Éº„Ç∏"""

    def render(self):
        st.header("ü§ñ AI „Ç¢„Ç∑„Çπ„Çø„É≥„ÉàÔºàMCPÁµåÁî±Ôºâ")

        # „Çµ„Éº„Éê„ÉºÁä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ
        if not self._check_servers():
            return

        # API „Ç≠„Éº„ÉÅ„Çß„ÉÉ„ÇØ
        if not self._check_api_key():
            return

        # „Çµ„É≥„Éó„É´Ë≥™Âïè
        self._render_sample_questions()

        # „ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥
        self._render_chat_history()

        # „ÉÅ„É£„ÉÉ„ÉàÂÖ•Âäõ
        self._handle_chat_input()

    def _check_servers(self) -> bool:
        """„Çµ„Éº„Éê„ÉºÁä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ"""
        status = self.status_manager.check_all_servers()
        servers_ready = all("üü¢" in s["status"] for s in status.values())

        if not servers_ready:
            st.warning("‚ö†Ô∏è ‰∏ÄÈÉ®„ÅÆ„Çµ„Éº„Éê„Éº„Å´Êé•Á∂ö„Åß„Åç„Åæ„Åõ„Çì„ÄÇMCP„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
            st.code("""
# MCP„Çµ„Éº„Éê„Éº„ÇíËµ∑Âãï
docker-compose -f docker-compose.mcp-demo.yml up -d redis-mcp postgres-mcp es-mcp qdrant-mcp
            """)
            return False
        return True

    def _check_api_key(self) -> bool:
        """API „Ç≠„Éº„ÉÅ„Çß„ÉÉ„ÇØ"""
        import os
        if not os.getenv('OPENAI_API_KEY'):
            st.error("üîë OPENAI_API_KEY „ÅåË®≠ÂÆö„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ.env„Éï„Ç°„Ç§„É´„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ")
            return False
        return True

    def _render_sample_questions(self):
        """„Çµ„É≥„Éó„É´Ë≥™Âïè„ÅÆË°®Á§∫"""
        st.subheader("üí° „Çµ„É≥„Éó„É´Ë≥™Âïè")
        sample_questions = [
            "Redis„Å´‰øùÂ≠ò„Åï„Çå„Å¶„ÅÑ„Çã„Çª„ÉÉ„Ç∑„Éß„É≥Êï∞„ÇíÊïô„Åà„Å¶",
            "PostgreSQL„ÅÆÈ°ßÂÆ¢„ÉÜ„Éº„Éñ„É´„Åã„ÇâÊù±‰∫¨Âú®‰Ωè„ÅÆÈ°ßÂÆ¢„ÇíÊ§úÁ¥¢„Åó„Å¶",
            "Elasticsearch„Åß„ÄåPython„Äç„Å´Èñ¢„Åô„ÇãË®ò‰∫ã„ÇíÊ§úÁ¥¢„Åó„Å¶",
            "Qdrant„ÅÆÂïÜÂìÅ„Éô„ÇØ„Éà„É´„Åã„ÇâÈ°û‰ººÂïÜÂìÅ„ÇíË¶ã„Å§„Åë„Å¶",
            "‰ªäÊó•„ÅÆÂ£≤‰∏ä„Éá„Éº„Çø„ÇíÂàÜÊûê„Åó„Å¶"
        ]

        selected_question = st.selectbox(
            "Ë≥™Âïè„ÇíÈÅ∏ÊäûÔºà„Åæ„Åü„ÅØ‰∏ã„ÅÆ„ÉÅ„É£„ÉÉ„Éà„Å´Áõ¥Êé•ÂÖ•ÂäõÔºâ:",
            ["ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ..."] + sample_questions,
            key="question_selector"
        )

        if selected_question != "ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ..." and st.button("„Åì„ÅÆË≥™Âïè„Çí‰ΩøÁî®", key="use_question_btn"):
            st.session_state.messages.append({"role": "user", "content": selected_question})
            st.session_state.auto_process_question = True
            st.session_state.selected_tab_index = 1  # AI„ÉÅ„É£„ÉÉ„Éà„Éö„Éº„Ç∏„ÇíÁ∂≠ÊåÅ
            st.rerun()

    def _render_chat_history(self):
        """„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„ÅÆË°®Á§∫"""
        for message in st.session_state.messages:
            with st.chat_message(message["role"]):
                st.write(message["content"])

    def _handle_chat_input(self):
        """„ÉÅ„É£„ÉÉ„ÉàÂÖ•Âäõ„ÅÆÂá¶ÁêÜ"""
        prompt = st.chat_input("‰Ωï„ÅãË≥™Âïè„Åó„Å¶„Åè„Å†„Åï„ÅÑ")

        if st.session_state.auto_process_question or prompt:
            if st.session_state.auto_process_question:
                st.session_state.auto_process_question = False
                if st.session_state.messages and st.session_state.messages[-1]["role"] == "user":
                    current_prompt = st.session_state.messages[-1]["content"]
                else:
                    current_prompt = None
            else:
                current_prompt = prompt
                st.session_state.messages.append({"role": "user", "content": prompt})
                with st.chat_message("user"):
                    st.write(prompt)

            if current_prompt:
                self._generate_ai_response(current_prompt)

        # „ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„ÇØ„É™„Ç¢
        if st.button("üóëÔ∏è „ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„Çí„ÇØ„É™„Ç¢", key="clear_chat"):
            st.session_state.messages = []
            st.rerun()

    def _generate_ai_response(self, prompt: str):
        """AIÂøúÁ≠î„ÅÆÁîüÊàê"""
        with st.chat_message("assistant"):
            response_placeholder = st.empty()

            try:
                with st.spinner("AI „ÅåÂõûÁ≠î„ÇíÁîüÊàê‰∏≠..."):
                    # ÂÆüÈöõ„ÅÆMCPÂá¶ÁêÜ„ÅØ„Åì„Åì„Å´ÂÆüË£Ö
                    response_text = self._create_demo_response(prompt)

                    # „Çø„Ç§„Éó„É©„Ç§„Çø„ÉºÂäπÊûú
                    full_response = ""
                    for word in response_text.split():
                        full_response += word + " "
                        response_placeholder.markdown(full_response + "‚ñå")
                        time.sleep(0.05)

                    response_placeholder.markdown(response_text)
                    st.session_state.messages.append({"role": "assistant", "content": response_text})

            except Exception as e:
                error_msg = f"‚ùå „Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: {e}"
                response_placeholder.error(error_msg)
                st.session_state.messages.append({"role": "assistant", "content": error_msg})

    def _create_demo_response(self, prompt: str) -> str:
        """„Éá„É¢Áî®„É¨„Çπ„Éù„É≥„ÇπÁîüÊàê"""
        return f"""
ü§ñ **AI Assistant Response**

Ë≥™Âïè: "{prompt}"

Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„Åå„ÄÅÁèæÂú®MCP„Çµ„Éº„Éê„Éº„Å®„ÅÆÈÄ£Êê∫Ê©üËÉΩ„ÅØÈñãÁô∫‰∏≠„Åß„Åô„ÄÇ
‰ª£„Çè„Çä„Å´„ÄÅÂà©Áî®ÂèØËÉΩ„Å™„Éá„Éº„Çø„Å´„Å§„ÅÑ„Å¶Ë™¨Êòé„ÅÑ„Åü„Åó„Åæ„ÅôÔºö

**üìä Âà©Áî®ÂèØËÉΩ„Å™„Éá„Éº„Çø:**
- **Redis**: „Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ„ÄÅ„Ç´„Ç¶„É≥„Çø„ÄÅÊ§úÁ¥¢Â±•Ê≠¥
- **PostgreSQL**: È°ßÂÆ¢ÊÉÖÂ†±„ÄÅÊ≥®Êñá„Éá„Éº„Çø„ÄÅÂïÜÂìÅ„Ç´„Çø„É≠„Ç∞
- **Elasticsearch**: „Éñ„É≠„Ç∞Ë®ò‰∫ã„ÄÅÂÖ®ÊñáÊ§úÁ¥¢
- **Qdrant**: ÂïÜÂìÅ„Éô„ÇØ„Éà„É´„ÄÅÊé®Ëñ¶„Ç∑„Çπ„ÉÜ„É†

**üí° ÁèæÂú®„Åß„Åç„Çã„Åì„Å®:**
- "üìä Áõ¥Êé•„ÇØ„Ç®„É™" „Çø„Éñ„ÅßÂêÑ„Éá„Éº„Çø„Éô„Éº„Çπ„Å´Áõ¥Êé•„Ç¢„ÇØ„Çª„Çπ
- "üîç „Éá„Éº„ÇøÁ¢∫Ë™ç" „Çø„Éñ„Åß„ÉÜ„Çπ„Éà„Éá„Éº„Çø„ÅÆÁ¢∫Ë™ç
        """


# ==================================================
# „É°„Ç§„É≥„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥ÁÆ°ÁêÜ
# ==================================================
class MCPApplication:
    """MCP„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆ„É°„Ç§„É≥ÁÆ°ÁêÜ„ÇØ„É©„Çπ"""

    def __init__(self):
        self.status_manager = ServerStatusManager()
        self.sidebar_manager = SidebarManager(self.status_manager)

        # „Éö„Éº„Ç∏ÂÆöÁæ©
        self.tab_names = ["üîç „Éá„Éº„ÇøÁ¢∫Ë™ç", "ü§ñ AI „ÉÅ„É£„ÉÉ„Éà", "üìä Áõ¥Êé•„ÇØ„Ç®„É™", "üìà „Éá„Éº„ÇøÂàÜÊûê", "‚öôÔ∏è Ë®≠ÂÆö"]
        self.pages = self._initialize_pages()

    def _initialize_pages(self):
        """„Éö„Éº„Ç∏„ÅÆÂàùÊúüÂåñ"""
        from helper_mcp_pages import DirectQueryPage, DataAnalysisPage, SettingsPage

        return {
            0: DataViewPage("„Éá„Éº„ÇøÁ¢∫Ë™ç", self.status_manager),
            1: AIChatPage("AI„ÉÅ„É£„ÉÉ„Éà", self.status_manager),
            2: DirectQueryPage("Áõ¥Êé•„ÇØ„Ç®„É™", self.status_manager),
            3: DataAnalysisPage("„Éá„Éº„ÇøÂàÜÊûê", self.status_manager),
            4: SettingsPage("Ë®≠ÂÆö", self.status_manager),
        }

    def run(self):
        """„Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„ÅÆÂÆüË°å"""
        # „Çª„ÉÉ„Ç∑„Éß„É≥ÂàùÊúüÂåñ
        MCPSessionManager.init_session()

        # „Çµ„Ç§„Éâ„Éê„ÉºÊèèÁîª
        self.sidebar_manager.render_server_status()
        self.sidebar_manager.render_quick_actions()
        current_tab = self.sidebar_manager.render_navigation(self.tab_names)

        # ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏Ë°®Á§∫
        st.markdown(f"### ÁèæÂú®„ÅÆ„Éö„Éº„Ç∏: {self.tab_names[current_tab]}")

        # „Éö„Éº„Ç∏„Ç≥„É≥„ÉÜ„É≥„ÉÑ„ÅÆÊèèÁîª
        if current_tab in self.pages:
            self.pages[current_tab].render()
        else:
            st.warning(f"„Éö„Éº„Ç∏ {current_tab} „ÅØÂÆüË£Ö‰∏≠„Åß„Åô")


# ==================================================
# „Ç®„ÇØ„Çπ„Éù„Éº„Éà
# ==================================================
__all__ = [
    'MCPApplication',
    'MCPSessionManager',
    'ServerStatusManager',
    'RedisManager',
    'PostgreSQLManager',
    'ElasticsearchManager',
    'QdrantManager',
    'SidebarManager',
    'DataViewPage',
    'AIChatPage',
]
